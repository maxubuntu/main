前情回顾：

1.tcp 客户端

socket--->connect--->sen/recv---->close

2.收发缓冲区 协调收发速度

​	粘包：TCP，没有消息边界，多次发送内容被1次接收

3.UDP 

客户端： socket--->bind--->recvfrom/sendto---->close

客户端： socket---->sendto/recvfro---->close

4.广播 一端发送 多端接收

5.http协议  

格式： 请求格式 回应格式

请求格式： 请求行  GET  ? HTTP/1.1

​		请求头   key：value\r\n

​			空行

​			请求体

# 响应：

## 1.响应格式：响应行，响应头，空行，相应体



响应行：返回基本的情况

HTTP/1.1  	200        ok

版本信息		响应码	附加信息

响应码：1XX提示信息，表示请求被接收

​		2xx 响应成功

​		3xx响应需要进一步操做，重定向

​		4xx 客户端错误

​		5XX 服务器错误

## 2.响应头：对响应内容的描述

content-Type:text/html

###3空行、



##4.响应体：响应的主体信息	



# STRUCT模块的使用

1。原理 将一组简单的数据包进行打包，转换为bytes格式发送。

​	或将1组bytes格式数据，进行解析

2.接口使用

![](D:\python 学习笔记\pic\stuct1.jpg)

![](D:\python 学习笔记\pic\stuct3.jpg)

![](D:\python 学习笔记\pic\stuct2.jpg)

# 多任务编程

1.意义：充分利用计算机的多核资源，提高程序的运行效率

2.实现方案，多进程，多线程

3.并行与并发

​	并发：同时处理多个任务，内核在任务间不断的切换达到好像多个任务被同时执行的效果，实际每个时刻都只有一个任务占有内核 I/O操作

​	并行：多个任务利用计算机多喝资源同时执行，此时窦娥任务间为并行作用

# 进程（process)

## 进程理论基础

1.定义：程序在计算机中的1次运算

​	程序是一个可执行的文件，是静态的占有磁盘

​	进程是一个动态的过程描述，占有计算机资源，有一定的生命周期

2.系统中如何产生一个进场

​	1.用户空间通过调用程序接口或命令发起请求

​	2.操作胸痛接收用户请求，开始创建进程

​	3.操作系统调配计算机资源，确定进程状态等，

​	4.操作系统将创建按的进程提供给用户使用

![](D:\python 学习笔记\pic\进程1.jpg)

## 进程的基本概念：

1.cpu时间片：如果一个进程占有cpu内核则称这个程序在cpu时间片上

2.PCB(进程控制块)：在内存中开辟的一块空间，用于存放进程的基本信息，也用于系统查找识别进程。

3。进程ID（PID):系统为每个进程分配一个大于0的整数，作用进场id,每个进程id不重复

​	linux查看进场id: ps-aux

4.父子进程:系统中每个进程（初了系统初始化进程）都有唯一的父进程，可以有0个或多个子进程，父子进程关系便于进程管理。

查看树 ：pstree

5。进程状态：

​	三态：

​	就绪态 :进程具备执行条件，等待分配资源

​	运行态：进程占有cpu时间片正在运行

​	等待态：进程暂时停止运行，让出cpu

​	![](D:\python 学习笔记\pic\进程2.jpg)

![](D:\python 学习笔记\pic\进程3.jpg)

![](D:\python 学习笔记\pic\进程4.jpg)

进程的运行特征：

1.进程可以使用计算机多核资源。

2.进程是计算机分配资源的最小单位

3.进程之间的运行互不影响，各自独立

4.每个进程拥有独立的空间，各自使用自己的空间资源

### 面试要求

1.什么是进程，进程和程序的区别

2.进程有哪些状体，状态之间如何转化



# 基于fork的多进程编程

fork使用

pie=os.fork()

功能：创建新的进程

返回值：整数，如果创建失败，返沪一个负数，如果成功则在原有返回新进程的PID,在新进程中返回0

```python
import  os
pid = os.fork()
if pid <0 :
    print('创建进程失败')
elif pid == 0:
    print('这是一个新进程')
else:
    print('这是一个老进程')
print('fork test over',pid)
```



![](D:\python 学习笔记\pic\进程5.jpg)

复制父进程的内存空进代码段

![](D:\python 学习笔记\pic\进程6.jpg)

![](D:\python 学习笔记\pic\进程7.jpg)

# 进程的相关函数：

os.getpid()

功能：获取一个进程的pid

返回当前进程的pid

os.getppid()

功能：获取父进程的pid号

返回值：返回父进程id

os._exit(status)

功能：结束一个进程

参数：进程的中止状态 0一般认为是正常退出，其他数字认为是异常退出

sys.exit(【status】)

功能：退出进程

参数：整数，表示退出状态 默认0

字符串表示退出时打印内容。

```
import sys,os
#os_exit(0) #退出进程
#父子进程各自退出不会影响到对方的进程继续运行。
sys.exit('退出) # 退出进程
```



# 孤儿和僵尸

父进程退出，子进程没退出，就是孤儿进程，此时系统进程就会称为孤儿进程新的父进程，孤儿进程退出该进程会自动处理。

僵尸进程：子进程先于父进程退出，父进程又没有处理子进程的退出状态，此时子进程就会被称为僵尸进程。

特点：僵尸进程虽然结束，但会存留部分PCB在内存中，大量的僵尸进程会浪费系统的内存资源。

## 如何避免僵尸：

## 使用wait函数处理子进程退出

pid,status = os.wait()

功能： 在父进程中组赛等待处理子进程退出

返回值： pid 退出的字进程pid

​		status:子进程退出状态

os.wait()是个阻塞函数，使得主进程必须等待子进程结束

```python
'''僵尸处理'''
import sys,os
pid = os.fork()
if pid <0:
    print('process error')
elif pid =0:
    print('chlid pid:',os.getpid())
    sys.exit(2)
else:
    '''
    os.wait()处理僵尸进程 wait是阻塞函数 
    '''
    pid,status =os.wait()
    print('pid',pid)
    print('status:',status)#child退出状态*256
    while True
    	pass   
	
```

##创建二级子进程处理僵尸

1.父进程创建子进程，等待回收子进程

2.子进程创建二级子进程然后退出

3.二级子进程称为孤儿，和原来 的父进程一同执行事件

## 通过信号处理子进程退出

原理：子进程退出时会发送信号给父进程，如果父进程忽略子进程信号，则系统会自动处理子进程的退出

方法：使用signal模块在父进程创建子进程前写如下语句：

```
import signal
signal.singal(signal.SIGCHLD,signal.SIG_IGN)
```



![](D:\python 学习笔记\pic\进程8.jpg)

# 作业

1.fork理解和使用

2.IO函数总结1下

3.群聊聊天室

  	1)有人进入聊天室需要输入姓名，姓名不能重复

​	2）有人进入聊天室，其他人会收到 XX进入了聊天室

​	3）一个人发消息，其他人会收到：XXX:XXX

​	4)有人退出聊天室，其他人也会收到XXX退出聊天室

​	5)扩展功能：服务器可以向所有人发公告管理员消息：XXXX

