f

# day5

回顾

1.二分查找（选择和插入排序）

2.io操作	 IO密集型，计算密集型

3.文件读写操作

1. ​	打开  open

2. 读写      read(),readline() readlines() for item in 迭代

   ​		write()  writelines()

   3.关闭文件 close()

   4.文件打开方式

| r    | 读             | 文件必须存在               |
| ---- | -------------- | -------------------------- |
| w    | 写             | 文件不存在创建，存在清空   |
| a    | 写             | 文件不存在创建，存在继续写 |
| +    | 对原有权限加成 |                            |
| b    | 以二进制打开   |                            |

字节串：b"abcde"

str.encode()	bytes.decorde()



# with语句：

with context_expression [as target(s)]

​	with-body

python中的wit语句使用与读i资源进项访问的场合，保证不管处理过程中是否发生错误或异常都会执行规定的清理操作，释放被访问的资源，比如有文件读写后自动关闭，线程中锁的自动获取和释放等



```
with open('file','r+) as f:
	f.read()		
	注意：
	1.加b的打开方式读写要求必须都是字符串
	2.无论什么缓冲，当程序结束或者文件被关闭时都会将缓冲区内荣写入磁盘
```

with语句块，可以不用close()

# buffering:

1表示有行缓冲，默认是-1，默认则表示使用系统默认提供的缓冲机制，成功返回文件操作对象。

缓冲

![](D:\python 学习笔记\pic\缓冲区.jpg) 

```
buffer 文件读写缓冲机制。
缓冲刷新条件：
1.缓冲区满了会刷新。
2.行缓冲  换行时会自动刷新。
3.程序运行结束或文件clost关闭
4.调用flush()函数
```

```
"""
buffer 文件读写缓冲机制。
缓冲刷新条件：
1.缓冲区满了会刷新。
2.行缓冲  换行时会自动刷新。
3.程序运行结束或文件clost关闭
4.调用flush()函数
"""
f = open('text','w',1)
while True:
    data =input('>>')
    if not data:
        break
    f.write(data+'\n')
    #f.flush() 只要调用，自动刷新缓冲。
f.close()
```



# 文件按偏移量 

代表当前要操作文件的位置。

1.tell():获取文件偏移量大小

2.seek(offset[,whence]) ：移动文件偏移量位置

​	whence: 默认是0，表示从文件头开始算起

​			1代表从当前位开始算其

​			2代表从文件末尾算起

必须以二进制方式打开文件时基准位置才能是1或2

![](D:\python 学习笔记\pic\二进制偏移量.jpg)



# 文件描述符：

1.定义系统中每一个IO操作都会分配一个整数做为编号，该整数即这个io操作的文件描述符

2.获取： fileno()

# 文件管理器函数

| 获取文件大小     | os.path.getsize(file) |
| ---------------- | --------------------- |
| 查看文件列表     | os.listdir(dir)       |
| 查看文件是否存在 | os.path.exists(file)  |
| 判断文件类型     | os.path.isfile(file)  |
| 删除文件         | os.remove(file)       |
|                  |                       |
|                  |                       |
|                  |                       |
|                  |                       |
|                  |                       |

# 网络编程基础

OSI七层模型

![](D:\python 学习笔记\pic\iso7层.jpg)

# 四层协议 TCP/IP

![](D:\python 学习笔记\pic\tcpip四层协议.jpg)

![](D:\python 学习笔记\pic\tcpip四层协议2.jpg)

## 传输过程

1. 发送端由应用程序发送消息，逐层添加首部信息，最终在物理层发送信息包
2. 发送的消息经过多个节点（交换机，路由器）传输，最终到达目的地主机。
3. 目标主机由物理层逐层解析首部消息报，最终到达应用程序呈现消息

![](D:\python 学习笔记\pic\tcpip四层协议1.jpg)



## 网络协议

在网络传输中，都遵循规定，包括建立什么样的数据结构，什么样的特殊标志等。

## 网络基础的基本概念

ip地址， ipconfig

linux:ifconfig

确定电脑在网络的位置

### 端口号：

端口是网络地址的一部分，用于区分主机上不同的网络应用程序

特点，一个系统同的应用监听端口不能重复。

取值范围：1-65535

1-1023系统应用或大众程序监听端口

1024-65535 自用端口![](D:\python 学习笔记\pic\微信端口.jpg)

# 传输层服务

#面向连接的传输服务（基于tcp协议的数据传输）

1. 传输特征：提供了可靠的数据传输，可靠性指数据传输过程中无丢失，无失序，无差错，无重复
2. 实现手段：在通信前需要建立数据链接，通信结束要正常断开连接

##三次握手（建立连接）

客户端向服务器发送消息报文请求链接

服务器收报请求后，回复报文确定可以链接

客户端收到回复，发送最终报文链接建立

![](D:\python 学习笔记\pic\三次握手.jpg)

## 四次挥手

主动方发送报文请求断开连接，

被动方受到请求后，立即回复，表示准备断开

被动方准备就绪，再次发送报文表示可以断开

主动方受到确定，发送最终报文完成断开。

![](D:\python 学习笔记\pic\四次挥手.jpg)



# 面向无链接的传输服务（基于UDP协议的数据传输）

1. 传输特点：不保证传输的可靠性，传输过程没有链接和断开，数据收发自由随意
2. 使用情况：网路较差，对传输可靠性要求不高的，比如视频群聊 广播。



# socket套接字编程

套接字介绍：实现网络编程进行数据传输的一种技术手段

import socket

套接字分类：

流式套接字：sock_stream 以字节流方式传输数据，实现tcp网络传输方案（面向连接--tcp协议--可靠---流式套接字）

数据套接字：dock_DGRAM 以数据报形式传输数据，实现udp网络传输方案（面向无连接--udp协议--不可靠--数据套接字)



# TCP套接字编程

服务端流程： -->socket（买电话）--->bind(买电话卡）---->listen（冲话费）--->accept（开机)---->send/recv（说话）----->close（销毁）

##1.创建套接字

```
sockfd=socket.socket(socket_family=AF_INET,socket_typw = sock_STREAM,proto=0)

1. 参数 socket_family:网络地址类型 AF_INEt 表示 ipv4
2. socket_type:套接字类型 sock_STREAM SOCK_DGGRAM,  proto通常为0 选择子协议
3. 返回值：套接字对象

```

##2.绑定地址



```
sockfd.bind(addr)
功能：绑定本机网路地址
参数：二元元组（ip,port)  ('0.0.0.0',8888)
本地地址：'localhost',127.0.0.1'
网络地址：'172.40.90.185'
自动获取地址:'0.0.0.0'
```

![](D:\python 学习笔记\pic\套接字.jpg)

##3.设置监听：

```
sockfd.listen(n)
功能：将套接字设置为监听套接字，确定监听队列大小
参数，监听队列大小# 1个套接字服务端可以同时连接多个客户端，但需要一个一个来

```



## 4 。等待处理客户端的请求：

```
connfd,addr = sockfd.accept()
功能：阻塞等待处理的客户端请求，
返回值：connfd:客户端连接套接字
		addr=连接的客户端地址
阻塞等待：程序执行到这里会暂停执行，客户端什么发起连接请求，才开始执行，比如input sleep
connfd 客户端套接字：多个客户连接过来后，给分给各个客户一个专属套接字，
```

## 5.accept

消息收发

```
data =connfd.recv(fuffersize)
功能:接受客户端信息，
参数，每次最多接受消息的大小
——------------
n =connfd.send(data)
功能：要发送的内容 byets格式<--------
返回值：发送的字节数
发 收都要用字节串
```



## 6.关闭套接字

```
sockfd.clost()
关闭套接字
```



# 作业

1.将文件操作总结

2.总结面视要求题目的回答

3.尽快掌握服务端流程函数 ip的配合





